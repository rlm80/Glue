---
layout: base
title: Guide
---

<h2>Templates</h2>

<p>Low-level elements like operands in boolean expressions are a mix of arithmetic expressions, string concatenations, operators, functions, identifiers, string literals and pre-defined constants. It would be pointless and tedious to describe them as a tree of objects. Such elements are considered atomic, and must be described in SQL. Still, proprietary SQL cannot be used, since database independence would be lost. That is why "<b>pseudo SQL</b>" is introduced.</p>

<h3>Pseudo SQL</h3>

<p>Pseudo SQL is SQL code standardized in such a way that it can be easily converted into proprietary SQL, and its special characters don't need to be escaped in double-quoted PHP strings.</p>

<h4>String literals and identifiers</h4>

<p>String literals must be surrounded by simple quotes (') and identifiers by backticks (`). Inner occurrences of quoting characters must be doubled (e.g. string literal <i>my'test</i> becomes <i>'my''test'</i>, identifier <i>my`test</i> becomes <i>`my``test`</i>). Fortunately, most of the time it isn't necessary to explicitely quote anything, thanks to template fragments and table fragments, as explained below.</p>

<h4>Operators, functions and pre-defined constants</h4>

<p>The library doesn't impose any naming conventions. What's important is to be consistent accross the application. A hook ( <span class="inline_code">Connection::hook_sql_replace()</span> ) is provided so that name conversions from pseudo SQL to proprietary SQL can be implemented for a specific connection. By default the hook does nothing, so all names are passed from pseudo SQL to proprietary SQL as-is.</p>

<h3>Template fragments</h3>

<p>A template fragment is a string of pseudo SQL with placeholders, and an array of replacements. Placeholders can be either '?' or '!' : the former reserves space for a value, and the latter for an identifier. Replacements can be either PHP scalar values, arrays, or fragments. When a template fragment is compiled, the pseudo SQL string is turned into proprietary SQL. Then, replacements are quoted according to the conventions of the underlying RDBMS and placeholders are replaced. Replacements that are fragments are compiled and included as-is.</p>

<p>Thanks to replacements, explicitely quoting a value is almost never needed.</p>

{% highlight php %}
<?php

  use Glue\DB\DB;

  // Create fragment :
  $f = db::tpl("1=? AND 'test'=? AND `myid`=! AND 'a' IN ?", 2, "my'test", "my`id", array('a','b'));
  
  // Output SQL :
  echo db::cn()->compile($f);
  
  // Assuming a MySQL default connection, it prints :
  // 1=2 AND 'test'='my\'test' AND `myid`=`my``id` AND 'a' IN ('a','b')
?>
{% endhighlight %}

<h2>Table fragments</h2>

<p>Table fragments represent table-alias pairs. If the alias is omitted, a unique one is generated. Table fragments can be used to generate pseudo SQL expressions for fully qualified columns identifiers. This makes them especially useful into template fragments.</p>

<p>Thanks to table fragments and their use in templates, explicitely quoting an identifier is almost never needed.</p>

{% highlight php %}
<?php

  use Glue\DB\DB;

  // Explicit alias :
  echo db::cn()->compile( db::table('mytable', 'myalias') ); // For PostgreSQL, prints : "mytable" AS "myalias"
  
  // Automatic alias :
  echo db::cn()->compile( db::table('mytable') ); // For PostgreSQL, prints : "mytable" AS "mytable__0"
  echo db::cn()->compile( db::table('mytable') ); // For PostgreSQL, prints : "mytable" AS "mytable__1"
  echo db::cn()->compile( db::table('mytable') ); // For PostgreSQL, prints : "mytable" AS "mytable__2"

  // Column pseudo SQL generation :
  echo $f->column('mycolumn');  // Prints `myalias`.`mycolumn`
  echo $f->mycolumn;            // Prints `myalias`.`mycolumn` (shortcut)
  
  // Usage in template fragments :
  $tpl = db::tpl("$f->mycolumn = ?", "my'test");
  echo db::cn()->compile($tpl); // For PostgreSQL, prints "myalias"."mycolumn" = 'my\'test'
?>
{% endhighlight %}



























