---
layout: base
title: Guide
---

<h2>Fluent interfaces</h2>

<p>Each fragment exposes its data through a set of functions that all return <span class="inline_code">$this</span>, so that they can be chained one after the other. Such a set of functions is called a <a class="external" href="http://en.wikipedia.org/wiki/Fluent_interface">fluent interface</a> :</p>

{% highlight php %}
<?php
  
  use \Glue\DB\DB;
  
  // Chain of function calls, following the Fragment_Builder_Bool class API :
  echo DB::bool('1=1')->and('2=2')->or('3=3')->and("'test'='test'")->root()->sql();
  
  // Prints "1=1 AND 2=2 OR 3=3 AND 'test' = 'test'"
?>
{% endhighlight %}

<h2>Combining fluent interfaces</h2>

<p>A fluent interface provides a way of initializing the properties of a fragment in a single chain of function calls. But we have to build trees of fragments. Ideally this should also be done in a single chain of function calls. How can we assemble a tree of fragments, and initialize each new leaf we add by taking advantage of its own fluent interface, in a single chain of function calls ?</p>

<p>Three solutions to this problem have been used : <b>nested functions</b>, <b>wrappers</b> and <b>nested chaining</b>, the latter being the norm and the other the exception.</p>

<h3><a name="nested_functions">Nested functions</a></h3>

<p>All functions return <span class="inline_code">$this</span>. The chain of function calls that builds the child is used as a parameter of a function that adds the child to its parent.</p>

{% highlight php %}
<?php
  ParentFactory::create()
    ->addChild(
      ChildFactory::create()  // Function call nested inside another one
        ->setProp()
    )                         // Returns parent fragment.
    ->setProp();              // Keep on building parent fragment.
?>
{% endhighlight %}

<h3>Wrappers</h3>

<p>All functions return <span class="inline_code">$this</span>. The interface of the child is reproduced at the parent level and the parent forward the calls to the last added child.</p>

{% highlight php %}
<?php
  ParentFactory::create()
    ->addChild()      // Adds new child and returns parent fragment.
    ->childSetProp()  // Calls setProp() on the child that was just added and returns parent fragment
                      // => wrapper function for Child::setProp()
    ->setProp();      // Keep on building parent fragment.
?>
{% endhighlight %}

<h3>Nested chaining</h3>

<p>Functions that set parent properties return <span class="inline_code">$this</span>, but functions that add a new child return the child. There is a function on the child that returns the parent so that we can keep working on it once we're finished building the child.</p>

{% highlight php %}
<?php
  ParentFactory::create()
    ->addChild()      // Here returns child fragment !
      ->setProp()
      ->end()         // Returns control to parent fragment.
    ->setProp();      // Keep on building parent fragment.
?>
{% endhighlight %}

<h3>Simplified nested chaining</h3>

<p>Nested chaining can be simplified by forwarding any unknown function call on the child to the parent fragment. Function calls bubble up the fragment tree, starting from the current fragment, until they find an ancestor that supports the function. Thanks to this rule, calling <span class="inline_code">->end()</span> is almost always unneccessary.</p>

<p>Although this may seem a little convoluted, it's actually very natural because programming languages work that way. Consider the following SQL query :</p>

{% highlight sql %}
  SELECT *
  FROM
    "table1"
    LEFT OUTER JOIN "table2" ON
      "c1" = "c2" AND 
      "c3" = "c4" -- You don't have to use a special keyword to mark the end of the ON clause here !
                  -- The SQL parser knows that since "RIGHT OUTER JOIN" is not a valid boolean operator,
                  -- it must automatically end the boolean expression and return the control to the parent,
                  -- which is the join expression. This is how simplified nested chaining works.
    RIGHT OUTER JOIN "table3"
    -- ...
    ;
{% endhighlight %}

<h2>The ->root() function</h2>

<p>The root function is defined on every fragment class. When called on fragment F, it returns the root of the fragment tree that F is a part of. This is important when you want to make sure to target the top of the fragment tree instead of the current fragment, for example to generate the SQL resulting of the whole tree.</p>



























