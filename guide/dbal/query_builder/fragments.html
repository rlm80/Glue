---
layout: base
title: Guide
---

<h2>Fragments</h2>

<p>Queries are represented internally as <b>trees</b> of <b>fragments</b>.</p>

<p>Fragments are objects that hold data about a specific piece of SQL query and can be compiled into SQL strings. To generate its own SQL string, a parent fragment aggregates the SQL strings generated by its children fragments.</p>

<h3>Example</h3>

<p>The following example builds a boolean expression :</p>

{% highlight php %}
<?php

  use \Glue\DB\DB;
  
  // Builds boolean expression.
  $fragment = DB::bool('1=1')  // Adds boolean operand (Fragment_Operand_Bool).
                ->and('2=2')   // Adds boolean operand with AND connector.
                ->or('3=?', 3) // Adds boolean operand with OR connector.
                ->root();
  
  // Returns compiled SQL according to default connection SQL dialect.
  $sql = $fragment->sql();
  
  // prints "1=1 AND 2=2 OR 3=3"
  echo $sql;
?>
{% endhighlight %}

<p>The fragment tree would look as follows :</p>

{% highlight php %}
  +-- Boolean expression (SQL = "1=1 AND 2=2 OR 3=3")
    +-- Boolean operand (SQL = "1=1")
    | +-- Template (SQL = "1=1")
    +-- Boolean operand (SQL = "AND 2=2")
    | +-- Template (SQL = "2=2")
    +-- Boolean operand (SQL = "OR 3=3")
      +-- Template (SQL = "3=3")
        +-- Value (SQL = "3")
{% endhighlight %}

<h2>Fragment classes</h2>

<p>There is a fragment class for each piece that makes up an SQL query, like boolean expressions, boolean operands, join expressions, order by clause and so on. All fragment classes inherit from <a class="external" href="https://github.com/rlm80/Glue/blob/master/classes/system/db/fragment.php"><span class="inline_code">\Glue\DB\Fragment</span></a> so they all share some common attributes :</p>

<ul>
  <li><b>A <a class="external" href="https://github.com/rlm80/Glue/blob/master/classes/system/db/fragment.php"><span class="inline_code">public function sql(Connection $cn)</span></a> function </b>: this function returns the compiled SQL string formatted according to the SQL dialect of the given database connection.</li>
  <li><b>A <a class="external" href="https://github.com/rlm80/Glue/blob/master/classes/system/db/fragment.php"><span class="inline_code">protected $users</span></a> property </b>: all fragments that use the SQL generated by the current fragment to generate their own SQL are registered in the $users array of the current fragment.</li>
  <li><b>A <a class="external" href="https://github.com/rlm80/Glue/blob/master/classes/system/db/fragment.php"><span class="inline_code">protected $sql</span></a> property </b>: SQL cache to avoid compiling the fragment every time the sql() function is called. The cache is invalidated when a property is modified and the process is cascaded to the users of the fragment.</li>
  <li><b>A <a class="external" href="https://github.com/rlm80/Glue/blob/master/classes/system/db/fragment.php"><span class="inline_code">protected $context</span></a> property </b>: parent of the fragment in the query tree.</li>
</ul>

<h2>Fluent interfaces</h2>

<p>Each fragment exposes its data through a set of functions that all return <span class="inline_code">$this</span>, so that they can be chained one after the other. Such a set of functions is called a <a class="external" href="http://en.wikipedia.org/wiki/Fluent_interface">fluent interface</a> :</p>

{% highlight php %}
<?php
  
  use \Glue\DB\DB;
  
  // Chain of function calls, following the Fragment_Builder_Bool class API :
  echo DB::bool('1=1')->and('2=2')->or('3=3')->and("'test'='test'")->root()->sql();
  
  // Prints "1=1 AND 2=2 OR 3=3 AND 'test' = 'test'"
?>
{% endhighlight %}

<h2>Combining fluent interfaces</h2>

<p>A fluent interface provides a way of initializing the properties of a fragment in a single chain of function calls. But we have to build trees of fragments. Ideally this should also be done in a single chain of function calls. How can we assemble a tree of fragments, and initialize each new leaf we add by taking advantage of its own fluent interface, in a single chain of function calls ?</p>

<p>Three solutions to this problem have been used : <b>nested functions</b>, <b>wrappers</b> and <b>nested chaining</b>, the latter being the norm and the other the exception.</p>

<h3>Nested functions</h3>

<p>All functions return <span class="inline_code">$this</span>. The chain of function calls that builds the child is used as a parameter of a function that adds the child to its parent.</p>

{% highlight php %}
<?php
  ParentFactory::create()
    ->addChild(
      ChildFactory::create()  // Function call nested inside another one
        ->setProp()
    )                         // Returns parent fragment.
    ->setProp();              // Keep on building parent fragment.
?>
{% endhighlight %}

<h3>Wrappers</h3>

<p>All functions return <span class="inline_code">$this</span>. The interface of the child is reproduced at the parent level and the parent forward the calls to the last added child.</p>

{% highlight php %}
<?php
  ParentFactory::create()
    ->addChild()      // Adds new child and returns parent fragment.
    ->childSetProp()  // Calls setProp() on the child that was just added and returns parent fragment
                      // => wrapper function for Child::setProp()
    ->setProp();      // Keep on building parent fragment.
?>
{% endhighlight %}

<h3>Nested chaining</h3>

<p>Functions that set parent properties return <span class="inline_code">$this</span>, but functions that add a new child return the child. There is a function on the child that returns the parent so that we can keep working on it once we're finished building the child.</p>

{% highlight php %}
<?php
  ParentFactory::create()
    ->addChild()      // Here returns child fragment !
      ->setProp()
      ->end()         // Returns control to parent fragment.
    ->setProp();      // Keep on building parent fragment.
?>
{% endhighlight %}

<h3>Simplified nested chaining</h3>

<p>Nested chaining can be simplified by forwarding any unknown function call on the child to the parent fragment. Function calls bubble up the fragment tree, starting from the current fragment, until they find an ancestor that supports the function. Thanks to this rule, calling <span class="inline_code">->end()</span> is almost always unneccessary.</p>

<p>Although this may seem a little convoluted, it's actually very natural because programming languages work that way. Consider the following SQL query :</p>

{% highlight sql %}
  SELECT *
  FROM
    "table1"
    LEFT OUTER JOIN "table2" ON
      "c1" = "c2" AND 
      "c3" = "c4" -- You don't have to use a special keyword to mark the end of the ON clause here !
                  -- The SQL parser knows that since "RIGHT OUTER JOIN" is not a valid boolean operator,
                  -- it must automatically end the boolean expression and return the control to the parent,
                  -- which is the join expression. This is how simplified nested chaining works.
    RIGHT OUTER JOIN "table3"
    -- ...
    ;
{% endhighlight %}

<h2>The ->root() function</h2>

<p>The root function is defined on every fragment class. When called on fragment F, it returns the root of the fragment tree that F is a part of. This is important when you want to make sure to target the top of the fragment tree instead of the current fragment, for example to generate the SQL resulting of the whole tree.</p>



























