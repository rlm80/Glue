---
layout: base
title: Guide
---

<p>This page describes some of the inner workings of the library. You may skip it if you just want to get to the point.</p>

<h2>Fragments</h2>

<p>Queries are represented internally as <b>trees</b> of <b>fragments</b>.</p>

<p>Fragments are objects that hold data about a specific piece of SQL query and can be compiled into SQL strings. To generate its own SQL string, a parent fragment aggregates the SQL strings generated by its children fragments.</p>

<h3>Example</h3>

<p>The following example builds of the query tree of a boolean expression :</p>

{% highlight php %}
<?php
  // A fragment that provides a fluent interface to build a boolean expression.
  use \Glue\DB\Fragment_Builder_Bool;
  
  // Creates new fragment representing a boolean expression.
  $fragment = new Fragment_Builder_Bool();
  
  // Builds boolean expression.
  $fragment->init('1=1')  // Adds boolean operand (Fragment_Operand_Bool).
           ->and('2=2')   // Adds boolean operand with AND connector.
           ->or('3=?',3); // Adds boolean operand with OR connector.
  
  // Returns compiled SQL according to default connection SQL dialect.
  $sql = $fragment->sql();
  
  // prints "1=1 AND 2=2 OR 3=3"
  echo $sql;
?>
{% endhighlight %}

<p>The fragment tree would look as follows :</p>

{% highlight php %}
  +-- Boolean expression (SQL = "1=1 AND 2=2 OR 3=3")
    +-- Boolean operand (SQL = "1=1")
    | +-- Template (SQL = "1=1")
    +-- Boolean operand (SQL = "AND 2=2")
    | +-- Template (SQL = "2=2")
    +-- Boolean operand (SQL = "OR 3=3")
      +-- Template (SQL = "3=3")
        +-- Value (SQL = "3")
{% endhighlight %}

<h2>Fragment classes</h2>

<p>There is a fragment class for each piece that makes up an SQL query, like boolean expressions, boolean operands, join expressions, order by clause and so on. All fragment classes inherit from <a class="external" href="https://github.com/rlm80/Glue/blob/master/classes/system/db/fragment.php"><span class="inline_code">\Glue\DB\Fragment</span></a> so they all share some common attributes :</p>

<ul>
  <li><b>A <a class="external" href="https://github.com/rlm80/Glue/blob/master/classes/system/db/fragment.php"><span class="inline_code">public function sql(Connection $cn)</span></a> function </b>: this function returns the compiled SQL string formatted according to the SQL dialect of the given database connection.</li>
  <li><b>A <a class="external" href="https://github.com/rlm80/Glue/blob/master/classes/system/db/fragment.php"><span class="inline_code">protected $users</span></a> property </b>: all fragments that use the SQL generated by the current fragment to generate their own SQL are registered in the $users array of the current fragment.</li>
  <li><b>A <a class="external" href="https://github.com/rlm80/Glue/blob/master/classes/system/db/fragment.php"><span class="inline_code">protected $sql</span></a> property </b>: SQL cache to avoid compiling the fragment every time the sql() function is called. The cache is invalidated when a property is modified and the process is cascaded to the users of the fragment.</li>
  <li><b>A <a class="external" href="https://github.com/rlm80/Glue/blob/master/classes/system/db/fragment.php"><span class="inline_code">protected $context</span></a> property </b>: parent of the fragment in the query tree.</li>
</ul>

<h2>Fluent interfaces</h2>

<p>Each fragment exposes its data through a set of functions that all return <span class="inline_code">$this</span>, so that they can be chained one after the other. Such a set of functions is called a <a class="external" href="http://en.wikipedia.org/wiki/Fluent_interface">fluent interface</a> :</p>

{% highlight php %}
<?php
  // Chain of function calls, following the Fragment_Builder_Bool class API :
  $fragment->init('1=1')->and('2=2')->or('3=3')->and("'test'='test'");
?>
{% endhighlight %}

<h3>Nesting fluent interfaces</h3>

<p>A fluent interface provides a convenient way of initializing the properties of a single fragment. But we have to build trees of fragments. How can it be done in a single chain of function calls ?</p>

<p>Three solutions to this problem have been used : <b>nested functions</b>, <b>wrappers</b> and <b>nested chaining</b>, the latter being the most widespread in the library.</p>

{% highlight php %}
<?php
  // Nested functions :
  ParentFactory::create()
    ->addChild(
      ChildFactory::create()  // Function call nested inside another one
        ->setProp()
    )                         // Returns parent fragment.
    ->setProp();              // Keep on building parent fragment.
    
  // Wrappers :
  ParentFactory::create()
    ->addChild()      // Adds new child and returns parent fragment.
    ->childSetProp()  // Calls setProp() on the child that was just added and returns parent fragment
                      // => wrapper function for Child::setProp()
    ->setProp();      // Keep on building parent fragment.
  
  // Nested chaining :
  ParentFactory::create()
    ->addChild()      // Here returns child fragment !
      ->setProp()
      ->end()         // Returns control to parent fragment.
    ->setProp();      // Keep on building parent fragment.
?>
{% endhighlight %}

<p>Nested chaining can be simplified by forwarding any unknown function call to the parent fragment. Function calls bubble up the fragment tree, starting from the current fragment, until they find a ancestor fragment that supports the function. Thanks to this rule, calling ->end() is almost always unneccessary.</p>

<p>Although this may seem a little convoluted, it's actually very natural because languages work that way. Consider the following SQL query :</p>

{% highlight sql %}
<?php
  SELECT *
  FROM
    table1
    LEFT OUTER JOIN table2 ON
      c1 = c2 AND 
      c3 = c4 // <---- You don't have to use a special keyword to mark the end of the ON clause here !
                    // The parser knows that since "RIGHT OUTER JOIN" is not a valid boolean operator,
                    // it must automatically end the boolean expression and return the control to the
                    // join expression.
    RIGHT OUTER JOIN table3 ON
    // ...
?>
{% endhighlight %}

<h3>Example</h3>

<p>Here is a join expression that illustrates nested functions and nested chaining :</p>

{% highlight php %}
<?php

  use \Glue\DB\DB;
  
  // Build fragment :
  $join =
    DB::join('users', $u)
      ->left('profiles', $p)
        ->on("$u->id = $p->id")                   // Returns ON clause : nested chaining.
          ->and("?", DB::bool("1=1")->or("2=2") ) // Nested functions.
      ->left('posts', $po)            // No need to call ->end() : since ->left() isn't a valid function call
                                      // on a boolean expression, control is automatically returned to the join
                                      // expression.
        ->on("$po->user_id = $u->id")
      ->root();
      
  // Print SQL :
  echo $join->sql();
  
  // "users" LEFT OUTER JOIN "profiles" ON ("users"."id" = "profiles"."id" AND (1=1 OR 2=2)) LEFT OUTER JOIN posts ON ("posts"."user_id" = "users"."id")
?>
{% endhighlight %}





























