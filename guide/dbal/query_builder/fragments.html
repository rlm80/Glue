---
layout: base
title: Guide
---

<p>This page describes some of the inner workings of the library. You may skip it if you just want to get to the point.</p>

<h2>Fragments</h2>

<p>Queries are represented internally as <b>trees</b> of <b>fragments</b>.</p>

<p>Fragments are objects that hold data about a specific piece of SQL query and can be compiled into SQL strings. To generate its own SQL string, a parent fragment aggregates the SQL strings generated by its children fragments.</p>

<h3>Example</h3>

<p>The following example builds of the query tree of a boolean expression :</p>

{% highlight php %}
<?php
  // A fragment that provides a fluent interface to build a boolean expression.
  use \Glue\DB\Fragment_Builder_Bool;
  
  // Creates new fragment representing a boolean expression.
  $fragment = new Fragment_Builder_Bool();
  
  // Builds boolean expression.
  $fragment->init('1=1')  // Adds child fragment representig a boolean operand (Fragment_Operand_Bool).
           ->and('2=2')   // Adds child fragment representig a boolean operand with AND connector.
           ->or('3=?',3); // Adds child fragment representig a boolean operand with OR connector.
  
  // Returns compiled SQL according to default connection SQL dialect.
  $sql = $fragment->sql();
  
  // prints "1=1 AND 2=2 OR 3=3"
  echo $sql;
?>
{% endhighlight %}

<p>The fragment tree would look as follows :</p>

{% highlight php %}
  +-- Boolean expression (SQL = "1=1 AND 2=2 OR 3=3")
    +-- Boolean operand (SQL = "1=1")
    | +-- Template (SQL = "1=1")
    +-- Boolean operand (SQL = "AND 2=2")
    | +-- Template (SQL = "2=2")
    +-- Boolean operand (SQL = "OR 3=3")
      +-- Template (SQL = "3=3")
        +-- Value (SQL = "3")
{% endhighlight %}

<h2>Fragment classes</h2>

<p>There is a fragment class for each piece that makes up an SQL query, like boolean expressions, boolean operands, join expressions, order by clause and so on. All fragment classes inherit from <a class="external" href="https://github.com/rlm80/Glue/blob/master/classes/system/db/fragment.php"><span class="inline_code">\Glue\DB\Fragment</span></a> so they all share some common attributes :</p>

<ul>
  <li><b>A <a class="external" href="https://github.com/rlm80/Glue/blob/master/classes/system/db/fragment.php"><span class="inline_code">public function sql(Connection $cn)</span></a> function </b>: this function returns the compiled SQL string formatted according to the SQL dialect of the given database connection.</li>
  <li><b>A <a class="external" href="https://github.com/rlm80/Glue/blob/master/classes/system/db/fragment.php"><span class="inline_code">protected $users</span></a> property </b>: all fragments that use the SQL generated by the current fragment to generate their own SQL are registered in the $users array of the current fragment.</li>
  <li><b>A <a class="external" href="https://github.com/rlm80/Glue/blob/master/classes/system/db/fragment.php"><span class="inline_code">protected $sql</span></a> property </b>: SQL cache to avoid compiling the fragment every time the sql() function is called. The cache is invalidated when a property is modified and the process is cascaded to the users of the fragment.</li>
  <li><b>A <a class="external" href="https://github.com/rlm80/Glue/blob/master/classes/system/db/fragment.php"><span class="inline_code">protected $context</span></a> property </b>: parent of the fragment in the query tree.</li>
</ul>

<h2>Fluent interfaces</h2>

<p>Each fragment exposes its data through a set of functions that all return <span class="inline_code">$this</span>, so that they can be chained one after the other. Such a set of functions is called a <a class="external" href="http://en.wikipedia.org/wiki/Fluent_interface">fluent interface</a> :</p>

{% highlight php %}
<?php
  // Chain of function calls, following the Fragment_Builder_Bool class API :
  $fragment->init('1=1')->and('2=2')->or('3=3')->and("'test'='test'");
?>
{% endhighlight %}

<h3>Nesting fluent interfaces</h3>

<p>Parent fragments define a fluent interface through which their properties can be set, and children fragments can be added. These children fragments may also define their own fluent interfaces. Think for example of a join expression that may have ON boolean expressions among its children. How can such a tree of fragments be conveniently built without breaking fluency ?</p>

<p>There are three solutions to this problem. <b>Nested functions</b>, <b>wrappers</b> and <b>nested chaining</b> :</p>

{% highlight php %}
<?php
  // Nested functions :
  ParentFactory::create()
    ->addChild(
      ChildFactory::create()  // Function call nested inside another one
        ->setProp()
    )                         // Returns parent fragment.
    ->setProp();              // Keep on building parent fragment.
    
  // Wrappers :
  ParentFactory::create()
    ->addChild()      // Adds new child and returns parent fragment.
    ->childSetProp()  // Calls setProp() on the child that was just added and returns parent fragment
                      // => wrapper function for Child::setProp()
    ->setProp();      // Keep on building parent fragment.
  
  // Nested chaining :
  ParentFactory::create()
    ->addChild()      // Here returns child fragment !
      ->setProp()
      ->end()         // Returns control to parent fragment.
    ->setProp();      // Keep on building parent fragment.
?>
{% endhighlight %}

<p>There is no clear winner. One may be more convenient than another depending on the case. All three solutions have been used throughout the library, although nested chaining was the most widely used.</p>

<p>Nested chaining can be simplified by forwarding any unknown call on the current fragment to its parent. This rule makes calling ->end() unneccessary 99% of the time. Function calls bubble up the fragment tree until they find a fragment where the call applies. So :</p>

{% highlight php %}
<?php
  // The follwing code :
  ParentFactory::create()
    ->addChild()
      ->setThis()
      ->end()
    ->setThat();
    
  // Can be simplified like this :
  ParentFactory::create()
    ->addChild()
      ->setThis()
    ->setThat();
    
  // ...because the library understand that since ->setThat() doesn't apply to the child fragment,
  // it must automatically return the control to the parent fragment, no need to call ->end() explicitely.
?>
{% endhighlight %}


<p>Here is a join expression that illustrates nested functions and nested chaining :</p>

{% highlight php %}
<?php

  use \Glue\DB\DB;
  
  // Build fragment :
  $join =
    DB::join('users', $u)
      ->left('profiles', $p)
        ->on("$u->id = $p->id")
          ->and("?",
            DB::bool("1=1")->or("2=2")
          )
      ->left('posts', $po)
        ->on("$po->user_id = $u->id")
      ->root();
      
  // Print SQL :
  echo $join->sql();
?>
{% endhighlight %}





























