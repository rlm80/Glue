---
layout: base
title: Guide
---

<h2>Fragments</h2>

<p>Queries are represented internally as <b>trees</b> of <b>fragments</b>.</p>

<p>Fragments are objects that hold data about a specific piece of SQL query and can be compiled into SQL strings. To generate its own SQL string, a parent fragment aggregates the SQL strings generated by its children fragments.</p>

<h3>Example</h3>

<p>The following example builds the query tree of a boolean expression :</p>

{% highlight php %}
<?php

  use \Glue\DB\DB;
  
  // Builds boolean expression.
  $fragment = DB::bool('1=1')  // Adds boolean operand (Fragment_Operand_Bool).
                ->and('2=2')   // Adds boolean operand with AND connector.
                ->or('3=?', 3) // Adds boolean operand with OR connector.
                ->root();
  
  // Returns compiled SQL according to default connection SQL dialect.
  $sql = $fragment->sql();
  
  // prints "1=1 AND 2=2 OR 3=3"
  echo $sql;
?>
{% endhighlight %}

<p>The fragment tree would look as follows :</p>

{% highlight php %}
  +-- Boolean expression (SQL = "1=1 AND 2=2 OR 3=3")
    +-- Boolean operand (SQL = "1=1")
    | +-- Template (SQL = "1=1")
    +-- Boolean operand (SQL = "AND 2=2")
    | +-- Template (SQL = "2=2")
    +-- Boolean operand (SQL = "OR 3=3")
      +-- Template (SQL = "3=3")
        +-- Value (SQL = "3")
{% endhighlight %}

<h2>Fragment classes</h2>

<p>There is a fragment class for each piece that makes up an SQL query, like boolean expressions, boolean operands, join expressions, order by clause and so on. All fragment classes inherit from <a class="external" href="https://github.com/rlm80/Glue/blob/master/classes/system/db/fragment.php"><span class="inline_code">\Glue\DB\Fragment</span></a> so they all share some common attributes :</p>

<ul>
  <li><b>A <a class="external" href="https://github.com/rlm80/Glue/blob/master/classes/system/db/fragment.php"><span class="inline_code">public function sql(Connection $cn)</span></a> function </b>: this function returns the compiled SQL string formatted according to the SQL dialect of the given database connection.</li>
  <li><b>A <a class="external" href="https://github.com/rlm80/Glue/blob/master/classes/system/db/fragment.php"><span class="inline_code">protected $users</span></a> property </b>: all fragments that use the SQL generated by the current fragment to generate their own SQL are registered in the $users array of the current fragment.</li>
  <li><b>A <a class="external" href="https://github.com/rlm80/Glue/blob/master/classes/system/db/fragment.php"><span class="inline_code">protected $sql</span></a> property </b>: SQL cache to avoid compiling the fragment every time the sql() function is called. The cache is invalidated when a property is modified and the process is cascaded to the users of the fragment.</li>
  <li><b>A <a class="external" href="https://github.com/rlm80/Glue/blob/master/classes/system/db/fragment.php"><span class="inline_code">protected $context</span></a> property </b>: parent of the fragment in the query tree.</li>
</ul>

<h2>Fluent interfaces</h2>

<p>Each fragment exposes its data through a set of functions that all return <span class="inline_code">$this</span>, so that they can be chained one after the other. Such a set of functions is called a <a class="external" href="http://en.wikipedia.org/wiki/Fluent_interface">fluent interface</a> :</p>

{% highlight php %}
<?php
  
  use \Glue\DB\DB;
  
  // Chain of function calls, following the Fragment_Builder_Bool class API :
  echo DB::bool('1=1')->and('2=2')->or('3=3')->and("'test'='test'")->root()->sql();
  
  // Prints "1=1 AND 2=2 OR 3=3 AND 'test' = 'test'"
?>
{% endhighlight %}

<h2>Nesting fluent interfaces</h2>

<p>A fluent interface provides a convenient way of initializing the properties of a single fragment. But we have to build trees of fragments. How can it be done in a single chain of function calls ?</p>

<p>Three solutions to this problem have been used : <b>nested functions</b>, <b>wrappers</b> and <b>nested chaining</b>, the latter being the most widespread in the library.</p>

<h3>Nested functions</h3>

<p>TODO : describe this</p>

{% highlight php %}
<?php
  ParentFactory::create()
    ->addChild(
      ChildFactory::create()  // Function call nested inside another one
        ->setProp()
    )                         // Returns parent fragment.
    ->setProp();              // Keep on building parent fragment.
?>
{% endhighlight %}

<h3>Wrappers</h3>

<p>TODO : describe this</p>

{% highlight php %}
<?php
  ParentFactory::create()
    ->addChild()      // Adds new child and returns parent fragment.
    ->childSetProp()  // Calls setProp() on the child that was just added and returns parent fragment
                      // => wrapper function for Child::setProp()
    ->setProp();      // Keep on building parent fragment.
?>
{% endhighlight %}

<h3>Nested chaining</h3>

<p>TODO : describe this</p>

{% highlight php %}
<?php
  ParentFactory::create()
    ->addChild()      // Here returns child fragment !
      ->setProp()
      ->end()         // Returns control to parent fragment.
    ->setProp();      // Keep on building parent fragment.
?>
{% endhighlight %}

<h3>Simplified nested chaining</h3>

<p>Nested chaining can be simplified by forwarding any unknown function call to the parent fragment. Function calls bubble up the fragment tree, starting from the current fragment, until they find an ancestor that supports the function. Thanks to this rule, calling <span class="inline_code">->end()</span> is almost always unneccessary.</p>

<p>Although this may seem a little convoluted, it's actually very natural because programming languages work that way. Consider the following SQL query :</p>

{% highlight sql %}
  SELECT *
  FROM
    "table1"
    LEFT OUTER JOIN "table2" ON
      "c1" = "c2" AND 
      "c3" = "c4" -- You don't have to use a special keyword to mark the end of the ON clause here !
                  -- The parser knows that since "RIGHT OUTER JOIN" is not a valid boolean operator,
                  -- it must automatically end the boolean expression and return the control to parent,
                  -- which is the join expression. This is simplified nested chaining.
    RIGHT OUTER JOIN "table3"
    -- ...
    ;
{% endhighlight %}

<h3>Example</h3>

<p>Here is a join expression that illustrates nested functions and simplified nested chaining :</p>

{% highlight php %}
<?php

  use \Glue\DB\DB;
  
  // Build fragment :
  $join =
    DB::join('users', $u)
      ->left('profiles', $p)
        ->on("$u->id = $p->id")                   // Returns ON clause : nested chaining.
          ->and("?", DB::bool("1=1")->or("2=2") ) // Nested functions.
      ->left('posts', $po) // No need to call ->end() : since ->left() isn't a valid function call
                           // on a boolean expression, control is automatically returned to the join
                           // expression.
        ->on("$po->user_id = $u->id")
      ->root();
      
  // Print SQL :
  echo $join->sql();
  
  // "users" LEFT OUTER JOIN "profiles" ON ("users"."id" = "profiles"."id" AND (1=1 OR 2=2)) LEFT OUTER JOIN posts ON ("posts"."user_id" = "users"."id")
?>
{% endhighlight %}

<h2>The ->root() function</h2>

<p>The root function is defined on every fragment class. When called on fragment F, it returns the root of the fragment tree that F is a part of. This is important when you want to make sure to target the top of the fragment tree instead of the current fragment, for example to generate the SQL resulting of the whole tree.</p>



























