---
layout: base
title: Guide
---

<p>This page explains some of the inner workings of the library. You may skip it if you just want to get to the point.</p>

<h2>Fragments</h2>

<p>Queries are represented internally as <b>trees</b> of <b>fragments</b>.</p>

<p>Fragments are objects that hold data about a specific piece of SQL query and can be compiled into SQL strings. To generate its own SQL string, a parent fragment aggregates the SQL strings generated by its children fragments.</p>

<h3>Example</h3>

<p>The following example builds of the query tree of a boolean expression :</p>

{% highlight php %}
<?php
  // A fragment that provides a fluent interface to build a boolean expression.
  use \Glue\DB\Fragment_Builder_Bool;
  
  // Creates new fragment representing a boolean expression.
  $fragment = new Fragment_Builder_Bool();
  
  // Builds boolean expression.
  $fragment->init('1=1')  // Adds child fragment representig a boolean operand (Fragment_Operand_Bool).
           ->and('2=2')   // Adds child fragment representig a boolean operand with AND connector.
           ->or('3=?',3); // Adds child fragment representig a boolean operand with OR connector.
  
  // Returns compiled SQL according to default connection SQL dialect.
  $sql = $fragment->sql();
  
  // prints "1=1 AND 2=2 OR 3=3"
  echo $sql;
?>
{% endhighlight %}

<p>The fragment tree would look as follows :</p>

{% highlight php %}
  +-- Boolean expression (SQL = "1=1 AND 2=2 OR 3=3")
    +-- Boolean operand (SQL = "1=1")
    | +-- Template (SQL = "1=1")
    +-- Boolean operand (SQL = "AND 2=2")
    | +-- Template (SQL = "2=2")
    +-- Boolean operand (SQL = "OR 3=3")
      +-- Template (SQL = "3=3")
        +-- Value (SQL = "3")
{% endhighlight %}

<h2>Fragment classes</h2>

<p>There is a fragment class for each piece that makes up an SQL query, like boolean expressions, boolean operands, join expressions, order by clause and so on. All fragment classes inherit from <a class="external" href="https://github.com/rlm80/Glue/blob/master/classes/system/db/fragment.php"><span class="inline_code">\Glue\DB\Fragment</span></a> so they all share some common attributes :</p>

<ul>
  <li><b>A <a class="external" href="https://github.com/rlm80/Glue/blob/master/classes/system/db/fragment.php"><span class="inline_code">public function sql(Connection $cn)</span></a> function </b>: this function returns the compiled SQL string formatted according to the SQL dialect of the given database connection.</li>
  <li><b>A <a class="external" href="https://github.com/rlm80/Glue/blob/master/classes/system/db/fragment.php"><span class="inline_code">protected $users</span></a> property </b>: all fragments that use the SQL generated by the current fragment to generate their own SQL are registered in the $users array of the current fragment.</li>
  <li><b>A <a class="external" href="https://github.com/rlm80/Glue/blob/master/classes/system/db/fragment.php"><span class="inline_code">protected $sql</span></a> property </b>: SQL cache to avoid compiling the fragment every time the sql() function is called. The cache is invalidated when a property is modified and the process is cascaded to the users of the fragment.</li>
  <li><b>A <a class="external" href="https://github.com/rlm80/Glue/blob/master/classes/system/db/fragment.php"><span class="inline_code">protected $context</span></a> property </b>: parent of the fragment in the query tree.</li>
</ul>

<h2>Fluent interfaces</h2>

<p>Each fragment exposes its data through a set of functions that all return <span class="inline_code">$this</span>, so that they can be chained one after the other. Such a set of functions is called a <a class="external" href="http://en.wikipedia.org/wiki/Fluent_interface">fluent interface</a> :</p>

{% highlight php %}
<?php
  // Chain of function calls, following the Fragment_Builder_Bool class API :
  $fragment->init('1=1')->and('2=2')->or('3=3')->and("'test'='test'");
?>
{% endhighlight %}

<h3>Nested fluent interfaces</h3>































