---
layout: base
title: Guide
---

<h2>Items and builders</h2>

<p>An SQL query is made up of lists of elements, of which there are 8 types :</p>

<ul>
  <li>boolean expressions,</li>
  <li>join expressions,</li>
  <li>order by lists,</li>
  <li>group by lists,</li>
  <li>select list,</li>
  <li>columns lists in an insert query,</li>
  <li>values lists in an insert query,</li>
  <li>assignements lists in an update query.</li>
</ul>

<p>Each of these lists is represented as a pair of fragment classes :</p>

<ul>
  <li>item fragment : represents the elements that make up the list and provides getter/setters to access their data,</li>
  <li>builder fragment : represents the list and provides a <a class="external" href="http://en.wikipedia.org/wiki/Method_chaining">fluent interface</a> to build it.</li>
</ul>

<p>Builder classes are located in the <a class="external" href="https://github.com/rlm80/Glue/tree/master/classes/system/db/fragment/builder"><span class="inline_code">classes/system/db/fragment/builder/</span></a> folder. They all extend the <a class="external" href="https://github.com/rlm80/Glue/tree/master/classes/system/db/fragment/builder.php"><span class="inline_code">\Glue\DB\Fragment_Builder</span></a> class and thus share some common methods :</p>

<ul>
  <li><span class="inline_code">->pop()</span> : removes last item,</li>
  <li><span class="inline_code">->reset()</span> : removes all items,</li>
  <li><span class="inline_code">->is_empty()</span> : whether the list is empty,</li>
  <li><span class="inline_code">->first()</span> : returns first item,</li>
  <li><span class="inline_code">->last()</span> : returns last item,</li>
  <li><span class="inline_code">->children()</span> : returns the items array by reference.</li>
</ul>

<p>The following sections look into each type of lists one by one, giving an example of how to use their builders.</p>

<h2>Boolean expressions</h2>

<p>Builder : <a class="external" href="https://github.com/rlm80/Glue/tree/master/classes/system/db/fragment/builder/bool.php"><span class="inline_code">Fragment_Builder_Bool</span></a></p>

<p>Item : <a class="external" href="https://github.com/rlm80/Glue/tree/master/classes/system/db/fragment/item/bool.php"><span class="inline_code">Fragment_Item_Bool</span></a></p>

<p>Factory method : <span class="inline_code">DB::bool()</span></p>

<p>The item is an operator-operand pair. The operator can be either <span class="inline_code">DB::_OR</span> or <span class="inline_code">DB::_AND</span>, and the operand can be any fragment. It has 2 methods :</p>

<ul>
  <li><span class="inline_code">->operator()</span> : operator getter/setter,</li>
  <li><span class="inline_code">->operand()</span> : operand getter/setter.</li>
</ul>

<p>The builder has 4 methods, they all return <span class="inline_code">$this</span> :</p>

<ul>
  <li><span class="inline_code">->init()</span> : removes all items and initialize the expression with a first item (no operator),</li>
  <li><span class="inline_code">->and()</span> : adds a new item with AND operator (no operator if list is still empty),</li>
  <li><span class="inline_code">->or()</span> : adds a new item with OR operator (no operator if list is still empty),</li>
  <li><span class="inline_code">->not()</span> : toggles negation of the expression.</li>
</ul>

<p>The methods <span class="inline_code">init()</span>, <span class="inline_code">and()</span> and <span class="inline_code">or()</span> take the same parameters as <span class="inline_code">DB::tpl()</span>, that is, a string of pseudo SQL, followed by a list of replacements. Alternatively, they also accept a single fragment parameter. Calling the factory method is the same as creating a new object and calling <span class="inline_code">init()</span>.</p>

{% highlight php %}
<?php

  use Glue\DB\DB;

  // Create fragment :
  $f = db::bool("`column` = ?", "test")->and("1=?", 1)->or("2=2");
  
  // Output SQL :
  echo db::cn()->compile( $f ); // ("column" = 'test') AND (1=1) OR (2=2)
  
  // Nested boolean expressions and negation :
  $f = db::bool("1=1")->and($nested = db::bool());
  $nested->init("2=2")->and("3=3")->not();
  
  // Output SQL :
  echo db::cn()->compile( $f ); // (1=1) AND NOT ((2=2) OR (3=3))
  
  // Other ways of writing the same boolean expression :
  $f = db::bool("1=1")->and( db::bool("2=2")->and("3=3")->not() );
  $f = db::bool("1=1 AND NOT ?", db::bool("2=2")->and("3=3") );
?>
{% endhighlight %}

<h2>Join expressions</h2>

<p>Builder : <a class="external" href="https://github.com/rlm80/Glue/tree/master/classes/system/db/fragment/builder/join.php"><span class="inline_code">Fragment_Builder_Join</span></a></p>

<p>Item : <a class="external" href="https://github.com/rlm80/Glue/tree/master/classes/system/db/fragment/item/bool.php"><span class="inline_code">Fragment_Item_Join</span></a></p>

<p>Factory method : <span class="inline_code">DB::join()</span></p>

<p>The item is an operator-operand pair and a boolean expression (ON clause). The operator can be either <span class="inline_code">DB::INNER</span>, <span class="inline_code">DB::LEFT</span>, <span class="inline_code">DB::RIGHT</span> or <span class="inline_code">DB::COMMA</span>. The operand can be any fragment. It has 3 methods :</p>

<ul>
  <li><span class="inline_code">->operator()</span> : operator getter/setter,</li>
  <li><span class="inline_code">->operand()</span> : operand getter/setter,</li>
  <li><span class="inline_code">->on()</span> : returns the on clause.</li>
</ul>

<p>The builder has 8 methods, all of them return <span class="inline_code">$this</span> :</p>

<ul>
  <li><span class="inline_code">->init()</span> : removes all items and initialize the expression with a first item (no operator),</li>
  <li><span class="inline_code">->right()</span> : adds a new item with RIGHT OUTER JOIN operator (no operator if list is still empty),</li>
  <li><span class="inline_code">->left()</span> : adds a new item with LEFT OUTER JOIN operator (no operator if list is still empty),</li>
  <li><span class="inline_code">->inner()</span> : adds a new item with INNER JOIN operator (no operator if list is still empty),</li>
  <li><span class="inline_code">->comma()</span> : adds a new item with ',' join operator (no operator if list is still empty),</li>
  <li><span class="inline_code">->on()</span> :
    <ul>
      <li>without parameters, returns the ON clause of the last item,</li>
      <li>with parameters, forwards call to <span class="inline_code">->and()</span> method of the ON clause of the last item.</li>
    </ul>
  </li>
  <li><span class="inline_code">->and()</span> : forwards call to <span class="inline_code">->and()</span> method of the ON clause of the last item,</li>
  <li><span class="inline_code">->or()</span> : forwards call to <span class="inline_code">->or()</span> method of the ON clause of the last item.</li>
</ul>

<p>Calling the factory method is the same as creating a new builder and calling <span class="inline_code">init()</span>. The methods <span class="inline_code">init()</span>, <span class="inline_code">right()</span>, <span class="inline_code">left()</span>, <span class="inline_code">inner()</span> and <span class="inline_code">comma()</span> all take two parameters : </p>

<ol>
  <li>A table name, a (table name, table alias) array or any fragment.</li>
  <li>(optional) A variable passed by reference, to be filled with the operand of the join item. If a table name or a table-alias array was passed as first parameter, the operand is a table fragment.</li>
</ol>

{% highlight php %}
<?php

  use Glue\DB\DB;

  // Create fragment :
  $f = db::join('users', $u)->left(array('profiles', 'myalias'), $p)->on("$p->id = $u->id");
  
  // Output SQL (assuming PostgreSQL default connection) :
  echo db::cn()->compile( $f );
  // "users" AS "users_0" LEFT OUTER JOIN "profiles" AS "myalias" ON ("myalias"."id" = "users_0"."id")
  
  // Nested joins expressions and negation :
  $f = db::join('t1', $t1)->left(
         db::join('t2', $t2)->inner('t3', $t3)->on("$t2->col = $t3->col + ?", 5)
       )->on("$t2->id = $t1->id")->or("$t3->id = $t1->id");
  
  // Output SQL (assuming MySQL default connection) :
  echo db::cn()->compile( $f );
  // `t1` AS `t1_0` LEFT OUTER JOIN (`t2` AS `t2_0` INNER JOIN `t3` AS `t3_0` ON (`t2_0`.`col` = `t3_0`.`col` + 5)) ON (`t2_0`.`id` = `t1_0`.`id`) OR (`t3_0`.`id` = `t1_0`.`id`)
?>
{% endhighlight %}




























