---
layout: base
title: Guide
---
<h2>Database introspection</h2>

<p>Database introspection refers to the means of retrieving database schema meta-data : table names, column names, column types and indexes.</p>

<h3>Table data</h3>

<p>Table data is represented as instances of the <span class="inline_code">\Glue\DB\Table</span> class. These objects can be retrieved and used like this :</p>

{% highlight php %}
<?php
  
  use Glue\DB\DB;
  
  // Returns data about table 'mytable' of connection 'myconnection'
  $table = DB::cn('myconnection')->table('mytable');
  
  // Available data about that table :
  $name     = $table->name();     // Name
  $cn       = $table->cn();       // Connection
  $columns  = $table->columns();  // Columns array
  $pk       = $table->pk();       // Primary key columns array
  
?>
{% endhighlight %}

<h3>Column data</h3>

<p>Column data is stored in instances of the <span class="inline_code">\Glue\DB\Column</span> class. These objects can be retrieved and used like this :</p>

{% highlight php %}
<?php
  
  use Glue\DB\DB;
  
  // Returns data about column 'mycolumn' of table 'mytable' of connection 'myconnection'
  $column = DB::cn('myconnection')->table('mytable')->column('mycolumn');
  
  // Available data about that column :
  $name       = $column->name();        // Name
  $type       = $column->type()));      // Database type (as returned by RDBMS)
  $phptype    = $column->phptype());    // Most appropriate PHP type to store column data    
  $nullable   = $column->nullable());   // Whether or not column is nullable
  $maxlength  = $column->maxlength());  // Max length for character columns
  $precision  = $column->precision());  // Decimal(6,2) ? => precision = 6
  $scale      = $column->scale());      // Decimal(6,2) ? => scale = 2
  $default    = $column->default());    // Default column value (type casted according to php type)
  $auto       = $column->auto());       // Whether or not column is auto-incrementing
?>
{% endhighlight %}

<h3>Listing tables</h3>

{% highlight php %}
<?php
  
  use Glue\DB\DB;

  // List tables of default connection :
  $list   = DB::cn()->table_list(); // Returns array of table names indexed by names
  $tables = DB::cn()->tables();     // Returns array of table objects indexed by names
  
  // Checking existence of a table :
  $exists = DB::cn()->table_exists('mytable');

?>
{% endhighlight %}

<h3>Listing columns</h3>

{% highlight php %}
<?php
  
  use Glue\DB\DB;
  
  // Get table :
  $table = DB::cn()->table('mytable'); 

  // List columns :
  $list     = $table->column_list(); // Returns array of column names indexed by names
  $columns  = $table->columns();     // Returns array of column objects indexed by names
  
  // Checking existence of a column :
  $exists = $table->column_exists('mycolumn');

?>
{% endhighlight %}

<h3>Caching</h3>

<p>During a page load, all of these column and table objects are created upon first request and then reused. That is :</p>

{% highlight php %}
<?php
  
  use Glue\DB\DB;
  
  $t1 = DB::cn()->table('mytable');
  $t2 = DB::cn()->table('mytable');
  
  var_dump($t1 === $t2); // TRUE
  
  $c1 = $t1->column('mycolumn');
  $c2 = $t2->column('mycolumn');
  
  var_dump($c1 === $c2); // TRUE  
?>
{% endhighlight %}

<p>Between each page load, all introspected data is cached on disk as serialized <span class="inline_code">\Glue\DB\Table</span> objects. If you change the database schema, you must clear the cache by deleting the cache directory. If not in production, you may also disable the introspection cache entirely (see options).</p>

<h2>Views</h2>

<p>The library supports a basic kind of views.</p>

<p>Suppose you have an application that requires a User(login, password) table. But what you have in the database is a Person(name, password) table, a legacy table that you can't afford to refactor. Views offer a solution to this problem. By defining a User view you can turn the results of these queries :</p>

{% highlight php %}
<?php
  
  use Glue\DB\DB;
  
  // Returns data about the column 'login' of the database table 'User'
  $col_data = DB::table('User')->column('login');
  
  // Returns "SELECT `User`.`login` FROM `User`"
  $sql = DB::select('User', $m)->columns($m->login)->root()->sql();
  
?>
{% endhighlight %}

<p>...into this :</p>

{% highlight php %}
<?php
  
  use Glue\DB\DB;
  
  // Returns data about the column 'name' of the database table 'Person'
  $col_data = DB::table('User')->column('login');
  
  // Returns "SELECT `Person`.`name` FROM `Person`"
  $sql = DB::select('User', $m)->columns($m->login)->root()->sql();
  
?>
{% endhighlight %}

<p>Views are special <span class="inline_code">\Glue\DB\Table</span> objects. They behave just like tables, they show up in the introspection API and can be used in queries just the same. They have names and columns. However, unlike normal table objects, they are mapped to an underlying database table that may have a different name and different columns. That mapping is defined by creating a class that extends <span class="inline_code">\Glue\DB\Table</span> :</p>

{% highlight php %}
<?php
  // File classes/user/db/foo/bar.php
  
  namespace Glue\User\DB;
  
  class Table_User extends \Glue\DB\Table {
    
    // Override real table name :
    protected function init_name() {
      return 'Person';
    }
    
    // Override column alias for 'name' :
    public function get_column_alias(\Glue\DB\Column $column) {
      if ($column->name() === 'name')
        return 'login';
      return parent::get_column_alias($column);
    }
  }
?>
{% endhighlight %}

<p>The name of the class tells the library that the view is named 'User'. Overriding the init_name() function tells the library the underlying table is Person and overriding get_column_alias sets up the alias for the name column.</p>

